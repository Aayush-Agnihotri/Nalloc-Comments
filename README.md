# nalloc - off-heap memory allocators for Java

[![Build Status](https://drone.io/github.com/alaisi/nalloc/status.png)](https://drone.io/github.com/alaisi/nalloc/latest)

Nalloc contains factories for allocating Java objects from native heap and memory mapped files. Basically `void*` and `mmap` in Java.

Off-heap storage is usually required with huge datasets (eg. caches and data grids) or with systems with hard latency requirements (eg. stock trading). Instantiating tens of millions of data entries from JVM heap is slow and likely to cause GC trashing. Off-heap storage for N entries can be instantiated in O(1) and data be handled in pre-allocated arrays with direct pointer access.

Nalloc uses almost no JVM heap once initialized and is suitable for systems requiring "garbage free" design.

## Usage

### Hello world

```java
NativeHeapAllocator allocator = NativeHeapAllocator.Factory.create(Message.class);
Pointer<Message> ptr = allocator.malloc(Message.class);

Message message = ptr.deref();
message.content("Hello world!");
System.out.println(message.content());

ptr.free();
```

### Structs

Off-heap objects are modelled as c-style structs that have state but no behavior. Java representation is an interface annotated with `@com.github.nalloc.Struct`. Implementation for the interface is generated by the allocator.

```java
@Struct({
    @Field(name="id", type=Type.LONG) })
public interface Message {
    long id();
    void id(long id);
}
```

### Native heap

Access to native heap is provided by `com.github.nalloc.NativeHeapAllocator`.

### Memory mapped files

Access to memory mapped files is provided by `com.github.nalloc.MmapAllocator`.

## Examples

TODO.

